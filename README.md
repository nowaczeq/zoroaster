# ZOROASTER
### Video URL: https://youtu.be/6ZkwzMXTeRw?si=Y0u3NA7zcLf8NoPt
### Description:
Zoroaster is a web application designed to help in processing and logging emotions through the medium of music. You have the option to describe your current emotions, and create unique tracks by dragging notes onto a musicline. You can pick from strings, bases, and keys, each having several unique instruments, which you can utilise in the higher, medium, or lower pitch. After creating and naming your track, you can view your work in your account's track history, where you can see the time of creating your track, how you felt, and listen back to your creation.
The original idea for Zoroaster came from using a mobile application called Cove, which allowed users to meditate through creating short tracks of their own. While the app was incredibly unique, and helped me in many tough situations, it had a few technical problems: some notes would not get registered, some would be impossible to hear when overlapping, etc. Moreover, the app was removed from the stores and is no longer available. Thinking that this was a shame, and remembering the unique experience provided by the app, I decided to recreate it using the lessons of CS50.
I had debated several other ideas when creating my final project, including: a game utilising machine learning and Large Language Models in providing a unique experience, a recreation of another application lost to history, namely, the game 'The Curse', as well as some kind of project revolving around data science. I ultimately decided on creating Zoroaster because I felt I wanted to bring back the experience of Cove, and somehow improve upon it, possibly creating an experience no longer available for the user. When I settled on creating the mobile meditation app, I further debated several names, but settled on honoring the book I was reading at the time, Friedrich Nietsche's 'Thus Spoke Zarathustra'--and thus, Zoroaster was born.
Zoroaster utilises a Flask server supporting several routes, which generate HTML templates, styled by CSS and JavaScript. The users, as well as the tracks, are recorded in a SQL database. The underlying skeleton of the project is similar to that of Problem Set 9, which was my starting point in development.
** Zoroaster.db ** includes four databases, two of which are important: 'users' tracks the users registered in the app, and 'tracks' identifies the music created by each user, as well as the position of each note and the time of creation. The other databases are utilised in a temporary measure: 'moods' accepts the moods the user selects before creating the track, and 'track' processes the notes and their positions after creating a track. I realise using SQL databases in this manner is not good practice, but for the resources I had, this was the best I could come up with.
** helpers.py ** includes several lists utilised in the application: the list of moods which the user can describe their emotional state through, as well as the names of the instruments found in the keys, strings, and bases groups.
Here is the rundown of all templates in Zoroaster:
** layout.html ** specifies the general layout of the page. It includes links to register or login for logged out users, and access to track history, logout and track creation for logged ones, distinguishing them using Jinja syntax. It also includes links to Bootstrap, the CSS of which was utilised in the project.
** index.html ** is the landing page for logged out users. It gives them a brief welcome and explanation of the page, displaying its logo in svg. It also includes a link to acknowledgements, login and registration.
** indexlogged.html ** is the landing page for users who are logged in. It greets them using their first name, provided in their login form, and prompts them to create new tracks or see existing ones.
** register.html ** is the standard registration html form, which prompts the user for their first name, username, and password. Server then checks whether the username is taken, whether password matches with the confirmation, and inserts the user's data in the sql database.
** login.html ** is a standard login site. Upon typing their username and password and sending the form, server then checks the database for a match, and returns an error or a redirection to index_logged.html as a result.
** acknowledgements.html ** is a short page where I acknowledge all the inspiration that came to the project, as well as the authors of notes and pictures I have used in the project.
** moodselection.html ** allows users to select their moods before creating their track. It creates two button groups containing all of the available moods, defined in helpers.py. Upon selecting each mood, its value is added to the database (or removed if already there). Upon submitting the moods, the client side submits a fetch request with the JSON string of the array of all of the moods. These are then inserted into the moods database by the server. Again, terrible design I know but it's fixable.
** createtrack.html ** is where the real magic happens. There are several aspects of this layout which are going on:
- Firstly, the page displays four tracklines, defining the space where notes are registered. Perpendicular to those tracklines is a musicline; a line which loops over the user's screen. Whenever it encounters a note, it plays the correct sound from the static file.
- The musicline is animated through the anime.js animation engine. It loops around the user's screen and comes back.
- The musicline's position is established through the getBoundingClientRect method. It is then compared to the position of all notes on the screen, and whenever they are in contact, a note is played.
- The user can select either a base, a string, or a key. Using Jinja syntax, HTML iterates over the array of all available instruments (defined in helpers.py), and presents them to the user. Selecting an instrument will change the value of a display, so that the user can always see what instrument they have currently selected.
- The same method is used for the pitch, except there are only three choices of 'high', 'medium', and 'low'
- Upon selecting both the note and the pitch, Java Script code prepares the fetch request in order to hear the note. It gets the value of the display of the note, as well as the display of the pitch, to prepare the correct name of the file which is supposed to be fetched. It then sends the fetch request, which is then caught by the server in the '/static/sounds/<path:filename>' route, which sends back the correct file to be played.
- After this, a new element is created: an element with the class of 'draggable', which is the symbol for the note. The correct .png is used as the background for the symbol, and the button becomes draggable. The user can then drag it onto the tracklines, and, once it touches the musicline, a fetch request is sent to the server again, with the note and value determined by the element.
- There's also a trashcan! This guy's position is also compared with the position of each element, and if any draggable element touches it, the element gets deleted. This is a way for the user to get rid of unwanted notes.
- Finally, after the user presses the 'done' button, an array of all of the notes and all of their positions is created, which is then sent to the server, which inserts it into a temporary SQL database. Again, bad programming, but it is also fixable.
** finishtrack.html ** allows the user to name their track, and displays the moods that the user associated with the track at the beginning. After clicking 'done', the track (i.e. each of the notes and their positions) are inserted into the database.
It is worth noting that the position of the notes is determined by the amount of pixels they take up from the left. That is what is written into the database. This means that the app will not, at present, work, if the user uses two different computers with two different screen resolutions, but that is also a fixable problem, the solution to which I am working on.
** history.html ** is a table of all of the tracks the user created. It utilises data from the SQL database to create a table using Jinja syntax. The user can see the name of their track and the time when they created it. They can also listen to the track by clicking on a button next to it.
** trackdisplay.html ** displays the track that the user requested. It is possible to account for all of the tracks by creating a unique URL for each track, and then receiving it server-side with request.args.get. After getting the name of the track, the server extracts the notes and their positions from the sql database, and uses them to create a trackline very similar to that in createtrack.html. Here, the musicline is also animated, but the animation is only played when the user presses the play button, and does not loop, allowing the user to listen back to their songs one by one.
That is all of the html files! Many of them have their own accompanying script within the file. There are several bugs still present in the site: the moods are sometimes not registered properly, the position is received through pixels rather than the proportion of the users' screen, etc. However, I am still very proud of my program, and am happy to be sharing it with you!
Thank you to CS50 for a life-changing opportunity to study the art of programming, and I hope you enjoy creating your tracks in Zoroaster!